# Depth First Search, 깊이 우선 탐색으로 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다
# 그래프 = 노드(Node, =정점(Vertex) + 간선(Edge)
# 표현방식 = 인접 행렬 방식(Adjacency Matrix), 인접리스트 방식(Adjacency List)

# 인접행렬 방식
INF = 999999999     # 리스트 내에서는 연결되어있지 않은 노드끼리는 무한의 비용이라고 작성한다
graph = [           # 무한의 비용을 나타내기 위해서 정답이 될 수 없는 큰 값인 999999999를 넣어 초기화 하는 경우가 많다
    [0, 7, 5],
    [7, 0, INF],
    [4, INF, 0]
]
print(graph)

# 인접 리스트 방식
graph = [[] for _ in range(3)]

graph[0].append((1, 7))
graph[0].append((2, 5))

graph[1].append((0, 7))

graph[2].append((0, 5))

print(graph)

# 메모리 측면으로 바라보았을 때, 인접 행렬 방식은 모든 관계를 저장해야 하기 때문에 노드 개수가 많을 수록 인접 리스트 방식보다 메모리를 많이 소모한다
# 하지만, 인접 리스트 방식은 인접 행렬방식에 비해 속도는 느리다
# 따라서, 특정노드와 연결된 모든 인접 노드들을 순회해야한다면 인접 리스트방식이 인접 행렬 방식보다 메모리 효율이 좋다

# DFS 의 구체적인 동작과정
# 1. 탐색 시작 노드를 스택에 삽입하고 방문
# 2. 스택의 최상단 노드에 방문하지 않은 인접노드가 있으면, 그 인접 노드를 스택에 넣고 방문처리한다. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼낸다
# 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.


# 스택을 쓰지 않고 재귀함수를 이용하여 만든 DFS
def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=' ')
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)


graph = [
    [],
    [2, 3, 8],  # 1 과 연결된 노드
    [1, 7],     # 2 와 연결된 노드
    [1, 4, 5],  # ...
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현
visited = [False] * 9

# 노드의 트리형식 리스트, 시작노드, 노드방문 리스트
dfs(graph, 1, visited)

